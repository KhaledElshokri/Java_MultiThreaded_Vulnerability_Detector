import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

//
// Master Thread class
//
public class MasterThread extends Thread{
	
	String[] mTextFileArray;                 //Place holder for each line
	String mVulnPattern = "V04K4B63CL5BK0B"; //Stores vulnerability pattern we need to search for
	int mWorkerThreads = 2;                  //Number of running threads
	double mVulnCounter;                     //Number of detected vulnerabilities
	double mAverage = 0;                     //Initial value of approximation average
	double mApproximateAvg;                  //Average number of detected vulnerabilities
	int mNumberOfLines = 0;                  //Number of lines in the text file
	
	public MasterThread() {
		
		// Put File Path Here instead of mine lol
        // String wFilePath = "C:\\Users\\Khale\\eclipse-workspace\\Tech1_COEN346\\src\\vm_1.txt";
        String wFilePath = "C:\\Users\\kyler\\Downloads\\vm_1.txt";

        // FileReader and BufferedReader initialization
        FileReader wFileReader = null;
        BufferedReader wBufferedReader = null;
        

        try {
            // Create a FileReader object for the file
            wFileReader = new FileReader(wFilePath);
            
            // Wrap the FileReader in a BufferedReader for efficient reading
            wBufferedReader = new BufferedReader(wFileReader);
            
            //Initialize text file array
            int wLineCount = countLines(wFilePath);
            this.mTextFileArray = new String[wLineCount]; 

            // Read each line from the file and add it to the array
            String line;
            int index = 0;
            while ((line = wBufferedReader.readLine()) != null) {
                int logIndex = line.indexOf("log:"); // Find the index of the word "log"
                if (logIndex != -1) { // If "log:" is found in the line
                    String truncatedLine = line.substring(logIndex); // Truncate the line from "log:" to end
                    this.mTextFileArray[index] = truncatedLine; // Assign the truncated line to array
                } else {
                    this.mTextFileArray[index] = line; // If "log:" is not found, assign the original line to array
                }
                index++;
            }
        } catch (IOException e) {
            // Handle IO exceptions
            e.printStackTrace();
        } finally {
            // Close the BufferedReader and FileReader in a finally block to ensure resources are released
            try {
                if (wBufferedReader != null) {
                    wBufferedReader.close();
                }
                if (wFileReader != null) {
                    wFileReader.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }		
	}
	
    // Method to count the number of lines in a file
    private int countLines(String filePath) throws IOException {
        FileReader fileReader = new FileReader(filePath);
        BufferedReader bufferedReader = new BufferedReader(fileReader);
        
        while (bufferedReader.readLine() != null) {
            mNumberOfLines++;
        }
        bufferedReader.close();
        return mNumberOfLines;
    }
    
    //To update the value of the Approximate Average
    public void updateApproximateAverage() {
    	
    	//Calculating the approximate average value
    	this.mApproximateAvg = this.mVulnCounter/this.mNumberOfLines;
    	
    	if(this.mApproximateAvg - this.mAverage > 0.2) {
    		
    		try {
				sleep(2000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
    		
    		this.mAverage = this.mApproximateAvg;
    		this.mWorkerThreads += 2;
    		
    	}
    	
    }
    
    //Atomic function to increment the count of vulnerabilities
    public synchronized double incrementCount() {
    	return this.mVulnCounter++;
    	
    }


}

//
//  Worker Thread Class
//

class Worker extends Thread{
	
	MasterThread mMaster = null;
    String mLogStatment;
	
	public Worker(MasterThread iMaster, String iLogStatment) {
		
		this.mMaster = iMaster;
		mLogStatment = iLogStatment;
	}
	
	@Override
	public void run() {
		
		LevenshteinDistance wLevenshteinDistance = new LevenshteinDistance();
		
		//Iterate through the log statment
		for(int i = 0; i < mLogStatment.length() - 14; i++) {
			
			int wEndIndex = i + 14;//Length of the vulnerability Pattern
			String wSubStringOfLog = mLogStatment.substring(i,wEndIndex);//Create substring of the log
				
			wLevenshteinDistance.Calculate(mMaster.mVulnPattern,wSubStringOfLog);
		
		}//If a vulnerability is found increment the atomic Counter

        if(wLevenshteinDistance.acceptable_change) {            
            mMaster.incrementCount();            
        }	
	}
}
